#!/bin/bash

# 脚本名称: trigger_malware_backconnect_ports.sh
# 描述: 触发恶意软件后门端口检测规则
# 用途: 测试 EDR 规则 net_connection_win_malware_backconnect_ports.yml
# 警告: 此脚本仅用于安全测试目的

echo "=========================================="
echo "恶意软件后门端口连接测试脚本"
echo "用于触发 EDR 检测规则"
echo "=========================================="
echo ""

# 定义可疑端口列表（从规则中提取的部分端口）
SUSPICIOUS_PORTS=(
    4444    # 常见的后门端口
    8080    # HTTP代理端口
    8888    # 常见后门端口
    5552    # 后门端口
    777     # 后门端口
    666     # 后门端口
    1443    # 后门端口
    1515    # 后门端口
    1777    # 后门端口
    1817    # 后门端口
    1904    # 后门端口
    1960    # 后门端口
    2443    # 后门端口
    2448    # 后门端口
    3360    # 后门端口
    3675    # 后门端口
    3939    # 后门端口
    4040    # 后门端口
    4433    # 后门端口
    4438    # 后门端口
    4443    # 后门端口
    4455    # 后门端口
    5445    # 后门端口
    5649    # 后门端口
    6625    # 后门端口
    7210    # 后门端口
    8143    # 后门端口
    8843    # 后门端口
    9631    # 后门端口
    9943    # 后门端口
    10101   # 后门端口
    12102   # 后门端口
    12103   # 后门端口
    12322   # 后门端口
    13145   # 后门端口
    13394   # 后门端口
    13504   # 后门端口
    13505   # 后门端口
    13506   # 后门端口
    13507   # 后门端口
    14102   # 后门端口
    14103   # 后门端口
    14154   # 后门端口
    49180   # 后门端口
    65520   # 后门端口
    65535   # 后门端口
)

# 使用外部IP地址（确保不是本地/内网IP，以触发检测）
# 使用公共DNS服务器IP，这些IP通常不会响应这些端口，但会建立连接尝试
TARGET_IP="8.8.8.8"  # Google DNS
# 备选: TARGET_IP="1.1.1.1"  # Cloudflare DNS
# 备选: TARGET_IP="208.67.222.222"  # OpenDNS

# 测试的端口数量（避免测试所有端口，选择几个代表性的）
TEST_PORTS=(4444 8080 8888 5552 777 666 1443 1515 1777 1817)

echo "目标IP: $TARGET_IP"
echo "测试端口: ${TEST_PORTS[*]}"
echo ""
echo "开始测试连接..."
echo ""

# 检查可用的网络工具
check_tool() {
    if command -v "$1" &> /dev/null; then
        return 0
    else
        return 1
    fi
}

# 方法1: 使用 nc (netcat) 连接
test_with_nc() {
    local port=$1
    echo "[测试] 使用 nc 连接到 $TARGET_IP:$port"
    timeout 2 nc -zv "$TARGET_IP" "$port" 2>&1 | head -1
    sleep 0.5
}

# 方法2: 使用 telnet 连接
test_with_telnet() {
    local port=$1
    echo "[测试] 使用 telnet 连接到 $TARGET_IP:$port"
    timeout 2 telnet "$TARGET_IP" "$port" 2>&1 | head -1
    sleep 0.5
}

# 方法3: 使用 curl 连接（HTTP端口）
test_with_curl() {
    local port=$1
    echo "[测试] 使用 curl 连接到 $TARGET_IP:$port"
    timeout 2 curl -s --connect-timeout 1 "http://$TARGET_IP:$port" > /dev/null 2>&1
    if [ $? -eq 0 ] || [ $? -eq 28 ]; then
        echo "  连接尝试已发送"
    fi
    sleep 0.5
}

# 方法4: 使用 wget 连接（HTTP端口）
test_with_wget() {
    local port=$1
    echo "[测试] 使用 wget 连接到 $TARGET_IP:$port"
    timeout 2 wget --spider --timeout=1 "http://$TARGET_IP:$port" 2>&1 | head -1
    sleep 0.5
}

# 方法5: 使用 /dev/tcp (bash内置)
test_with_bash_tcp() {
    local port=$1
    echo "[测试] 使用 bash /dev/tcp 连接到 $TARGET_IP:$port"
    timeout 2 bash -c "echo > /dev/tcp/$TARGET_IP/$port" 2>&1
    sleep 0.5
}

# 方法6: 使用 Python 连接
test_with_python() {
    local port=$1
    echo "[测试] 使用 Python 连接到 $TARGET_IP:$port"
    timeout 2 python3 -c "
import socket
import sys
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    result = s.connect_ex(('$TARGET_IP', $port))
    s.close()
    sys.exit(0)
except:
    sys.exit(1)
" 2>&1
    sleep 0.5
}

# 主测试循环
for port in "${TEST_PORTS[@]}"; do
    echo "----------------------------------------"
    echo "测试端口: $port"
    echo "----------------------------------------"
    
    # 尝试使用不同的工具
    if check_tool nc; then
        test_with_nc "$port"
    elif check_tool telnet; then
        test_with_telnet "$port"
    elif check_tool curl; then
        if [ "$port" -eq 8080 ] || [ "$port" -eq 8888 ]; then
            test_with_curl "$port"
        else
            test_with_nc "$port" 2>/dev/null || test_with_telnet "$port" 2>/dev/null
        fi
    elif check_tool python3; then
        test_with_python "$port"
    elif [ -n "$BASH_VERSION" ]; then
        test_with_bash_tcp "$port"
    else
        echo "未找到可用的网络工具 (nc, telnet, curl, python3)"
        echo "尝试使用 bash /dev/tcp..."
        test_with_bash_tcp "$port"
    fi
    
    echo ""
done

echo "=========================================="
echo "测试完成！"
echo "请检查 EDR 系统是否检测到这些连接尝试"
echo "=========================================="

# 可选: 批量测试所有端口（注释掉以避免过多连接）
# echo ""
# echo "开始批量测试所有可疑端口..."
# for port in "${SUSPICIOUS_PORTS[@]}"; do
#     if check_tool nc; then
#         timeout 1 nc -zv "$TARGET_IP" "$port" > /dev/null 2>&1
#     elif check_tool python3; then
#         python3 -c "import socket; s=socket.socket(); s.settimeout(0.5); s.connect_ex(('$TARGET_IP', $port)); s.close()" > /dev/null 2>&1
#     fi
#     sleep 0.1
# done
# echo "批量测试完成"


